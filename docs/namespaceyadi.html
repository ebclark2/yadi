<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>YADI: yadi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YADI
   </div>
   <div id="projectbrief">YAMLDependencyInjection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">yadi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>YADI.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyadi_1_1adapter.html">adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a layer above <a class="el" href="structyadi_1_1factory.html#a600474900d2c6fa5d09935a641298bd5" title="Calls the initializer associated with type passing the given YAML config. ">factory&lt;BT&gt;::create</a>. This allows types such as templated containers to be created without registering initializers for each element type.  <a href="structyadi_1_1adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyadi_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory stores initializers and help informations for a given base type.  <a href="structyadi_1_1factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyadi_1_1factory__traits.html">factory_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory traits that can be changed for BT.  <a href="structyadi_1_1factory__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyadi_1_1yadi__help.html">yadi_help</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides help information without requiring the base type. <a class="el" href="structyadi_1_1yadi__help.html" title="Provides help information without requiring the base type. yadi_help also allows a human readable nam...">yadi_help</a> also allows a human readable name to be assigned to a base type. For example, std::string is easier to read then std::basic_string&lt;char, ...&gt;.  <a href="structyadi_1_1yadi__help.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyadi_1_1yadi__help__fetcher.html">yadi_help_fetcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type erasure for factory state, which is a map is string name to a struct with an initializer and help information. Only the help information is accessed.  <a href="structyadi_1_1yadi__help__fetcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a92290eb27cd90666aa87b17d854af9fe"><td class="memTemplParams" colspan="2"><a id="a92290eb27cd90666aa87b17d854af9fe"></a>
template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a92290eb27cd90666aa87b17d854af9fe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a> = typename <a class="el" href="structyadi_1_1factory__traits.html">factory_traits</a>&lt; BT &gt;::ptr_type</td></tr>
<tr class="memdesc:a92290eb27cd90666aa87b17d854af9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of pointer the BT factory creates. <br /></td></tr>
<tr class="separator:a92290eb27cd90666aa87b17d854af9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c8750f81d4b3525cc09362afe610ea"><td class="memTemplParams" colspan="2"><a id="a79c8750f81d4b3525cc09362afe610ea"></a>
template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a79c8750f81d4b3525cc09362afe610ea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initializer_type_t</b> = typename <a class="el" href="structyadi_1_1factory.html">factory</a>&lt; BT &gt;::initializer_type</td></tr>
<tr class="separator:a79c8750f81d4b3525cc09362afe610ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf71f730b2dddbbcb78db9a00dbdbed9"><td class="memTemplParams" colspan="2"><a id="adf71f730b2dddbbcb78db9a00dbdbed9"></a>
template&lt;typename BT &gt; </td></tr>
<tr class="memitem:adf71f730b2dddbbcb78db9a00dbdbed9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>yadi_info_t</b> = typename <a class="el" href="structyadi_1_1factory.html">factory</a>&lt; BT &gt;::yadi_info</td></tr>
<tr class="separator:adf71f730b2dddbbcb78db9a00dbdbed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0058efe8131ffa9184aa772e88c8f160"><td class="memItemLeft" align="right" valign="top">std::string const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a0058efe8131ffa9184aa772e88c8f160">type_by_value_key</a> ()</td></tr>
<tr class="memdesc:a0058efe8131ffa9184aa772e88c8f160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key used for initializers creating by value directly from yaml.  <a href="#a0058efe8131ffa9184aa772e88c8f160">More...</a><br /></td></tr>
<tr class="separator:a0058efe8131ffa9184aa772e88c8f160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39d8f532bdf81e833cb117160a6440a"><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr class="memitem:ac39d8f532bdf81e833cb117160a6440a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structyadi_1_1adapter.html">adapter</a>&lt; FT &gt;::output_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ac39d8f532bdf81e833cb117160a6440a">create</a> (std::string const &amp;type, YAML::Node const &amp;config={})</td></tr>
<tr class="memdesc:ac39d8f532bdf81e833cb117160a6440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as adapter&lt;FT&gt;::create(type, config);.  <a href="#ac39d8f532bdf81e833cb117160a6440a">More...</a><br /></td></tr>
<tr class="separator:ac39d8f532bdf81e833cb117160a6440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85138aa0433192beaf4d0e67dd50cb23"><td class="memTemplParams" colspan="2">template&lt;typename OT &gt; </td></tr>
<tr class="memitem:a85138aa0433192beaf4d0e67dd50cb23"><td class="memTemplItemLeft" align="right" valign="top">OT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a85138aa0433192beaf4d0e67dd50cb23">from_yaml</a> (YAML::Node const &amp;factory_config)</td></tr>
<tr class="memdesc:a85138aa0433192beaf4d0e67dd50cb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulls type and config from YAML. This function is especially usefil when loading nested types from YAML configuration. If factory_config is a scalar string it will be used as type. If factory_config is a map then "type" and "config" keys will be pulled from it and used as such, unless the base type indicates it should be created directly from yaml. In this case factory_config is used as the config passed to the adapter.  <a href="#a85138aa0433192beaf4d0e67dd50cb23">More...</a><br /></td></tr>
<tr class="separator:a85138aa0433192beaf4d0e67dd50cb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829744f635593fef1c05b0f9b01a8aa2"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a829744f635593fef1c05b0f9b01a8aa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a829744f635593fef1c05b0f9b01a8aa2">from_yaml_base</a> (YAML::Node const &amp;config={})</td></tr>
<tr class="memdesc:a829744f635593fef1c05b0f9b01a8aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to from_yaml&lt;ptr_type_t&lt;base_type&gt;&gt;(config)  <a href="#a829744f635593fef1c05b0f9b01a8aa2">More...</a><br /></td></tr>
<tr class="separator:a829744f635593fef1c05b0f9b01a8aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c72b55cccde908a9828431855e3b5e5"><td class="memTemplParams" colspan="2">template&lt;typename OT , typename OI &gt; </td></tr>
<tr class="memitem:a5c72b55cccde908a9828431855e3b5e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a5c72b55cccde908a9828431855e3b5e5">from_yamls</a> (YAML::Node const &amp;factory_configs, OI out)</td></tr>
<tr class="memdesc:a5c72b55cccde908a9828431855e3b5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate output iterator from sequence of factory configs (anything from_yaml accepts).  <a href="#a5c72b55cccde908a9828431855e3b5e5">More...</a><br /></td></tr>
<tr class="separator:a5c72b55cccde908a9828431855e3b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425268f5a35df74d449b5e1f44f39c22"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename OI &gt; </td></tr>
<tr class="memitem:a425268f5a35df74d449b5e1f44f39c22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a425268f5a35df74d449b5e1f44f39c22">from_yamls_base</a> (YAML::Node const &amp;factory_configs, OI out)</td></tr>
<tr class="memdesc:a425268f5a35df74d449b5e1f44f39c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to from_yamls&lt;ptr_type_t&lt;base_type&gt;&gt;(factory_configs, out);.  <a href="#a425268f5a35df74d449b5e1f44f39c22">More...</a><br /></td></tr>
<tr class="separator:a425268f5a35df74d449b5e1f44f39c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d761848d60ab00f257fdd9f5f2f21"><td class="memTemplParams" colspan="2">template&lt;typename OT &gt; </td></tr>
<tr class="memitem:ace9d761848d60ab00f257fdd9f5f2f21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ace9d761848d60ab00f257fdd9f5f2f21">parse</a> (OT &amp;out, YAML::Node const &amp;factory_config)</td></tr>
<tr class="memdesc:ace9d761848d60ab00f257fdd9f5f2f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate out from factory config. The factory type is derived from ptr_type.  <a href="#ace9d761848d60ab00f257fdd9f5f2f21">More...</a><br /></td></tr>
<tr class="separator:ace9d761848d60ab00f257fdd9f5f2f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44c4b60a83f69f69789b994c8ebb0db"><td class="memItemLeft" align="right" valign="top"><a id="af44c4b60a83f69f69789b994c8ebb0db"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>demangle</b> (const char *name)</td></tr>
<tr class="separator:af44c4b60a83f69f69789b994c8ebb0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df417ee34c190388417a55612ca14f"><td class="memTemplParams" colspan="2"><a id="a87df417ee34c190388417a55612ca14f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87df417ee34c190388417a55612ca14f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>demangle_type</b> ()</td></tr>
<tr class="separator:a87df417ee34c190388417a55612ca14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82056df230021b8fc8be27978644629d"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename IT , typename... ARGS&gt; </td></tr>
<tr class="memitem:a82056df230021b8fc8be27978644629d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a82056df230021b8fc8be27978644629d">ctr</a> (ARGS... args)</td></tr>
<tr class="memdesc:a82056df230021b8fc8be27978644629d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct IT via contructor with the given arguments. This is intended to be used with a yaml binding initializer such as make_sequence_initializer(&amp;<a class="el" href="namespaceyadi.html#a82056df230021b8fc8be27978644629d" title="Construct IT via contructor with the given arguments. This is intended to be used with a yaml binding...">ctr&lt;BT, IT, MyCtrArgs...&gt;</a>, ...).  <a href="#a82056df230021b8fc8be27978644629d">More...</a><br /></td></tr>
<tr class="separator:a82056df230021b8fc8be27978644629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8552ed4e9350993901558fb0db1e0906"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8552ed4e9350993901558fb0db1e0906"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a8552ed4e9350993901558fb0db1e0906">yaml_as</a> (YAML::Node const &amp;config)</td></tr>
<tr class="memdesc:a8552ed4e9350993901558fb0db1e0906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns config.as&lt;T&gt;(). Signature matches factory initializer.  <a href="#a8552ed4e9350993901558fb0db1e0906">More...</a><br /></td></tr>
<tr class="separator:a8552ed4e9350993901558fb0db1e0906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e6a880477f8ed0163fbfc66aa6e5ba"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename IT &gt; </td></tr>
<tr class="memitem:a29e6a880477f8ed0163fbfc66aa6e5ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a29e6a880477f8ed0163fbfc66aa6e5ba">init_no_arg</a> (YAML::Node const &amp;)</td></tr>
<tr class="memdesc:a29e6a880477f8ed0163fbfc66aa6e5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call no argument constructor.  <a href="#a29e6a880477f8ed0163fbfc66aa6e5ba">More...</a><br /></td></tr>
<tr class="separator:a29e6a880477f8ed0163fbfc66aa6e5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7bc09c5c23344ded1f10f21386272"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename IT &gt; </td></tr>
<tr class="memitem:afde7bc09c5c23344ded1f10f21386272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#afde7bc09c5c23344ded1f10f21386272">init_yaml</a> (YAML::Node const &amp;config)</td></tr>
<tr class="memdesc:afde7bc09c5c23344ded1f10f21386272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs IT via a constructor that accepts YAML and returns as pointer to BT, ptr_type_t&lt;BT&gt;.  <a href="#afde7bc09c5c23344ded1f10f21386272">More...</a><br /></td></tr>
<tr class="separator:afde7bc09c5c23344ded1f10f21386272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97efcea8efe1e35d98961c88e21d5b31"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a97efcea8efe1e35d98961c88e21d5b31"><td class="memTemplItemLeft" align="right" valign="top">initializer_type_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a97efcea8efe1e35d98961c88e21d5b31">make_caching_initializer</a> (initializer_type_t&lt; BT &gt; const &amp;initializing_initializer)</td></tr>
<tr class="memdesc:a97efcea8efe1e35d98961c88e21d5b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps initializer in caching functor. The wrapped initializer must produce a shared pointer. A weak pointer to the created shared pointer is stored upon first creation. In subsequence calls the weak pointer is checking and used if it's still valid, otherwise a new shared pointer is created and the weak pointer is updated.  <a href="#a97efcea8efe1e35d98961c88e21d5b31">More...</a><br /></td></tr>
<tr class="separator:a97efcea8efe1e35d98961c88e21d5b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eac695c975b9f2b7f9d9611725b94e"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a71eac695c975b9f2b7f9d9611725b94e"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a71eac695c975b9f2b7f9d9611725b94e">make_caching_initializer</a> (yadi_info_t&lt; BT &gt; yi)</td></tr>
<tr class="memdesc:a71eac695c975b9f2b7f9d9611725b94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which updated just the initializer of a yadi info. See make_caching_initializer(initializer_type_t&lt;BT&gt;)  <a href="#a71eac695c975b9f2b7f9d9611725b94e">More...</a><br /></td></tr>
<tr class="separator:a71eac695c975b9f2b7f9d9611725b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904dc2ee15dbdedd1b2dac4e0420fe15"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:a904dc2ee15dbdedd1b2dac4e0420fe15"><td class="memTemplItemLeft" align="right" valign="top">initializer_type_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15">make_map_initializer</a> (F func, std::vector&lt; std::string &gt; fields)</td></tr>
<tr class="memdesc:a904dc2ee15dbdedd1b2dac4e0420fe15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence in the order the fields are provided. Once the sequence is created it's treated the behavior is the same as <a class="el" href="namespaceyadi.html#ac81e360a765ce7e454fa3971f1f06cdd" title="Creates factory initializer that expects a YAML sequence. The elements of the sequence will be passed...">make_sequence_initializer(F)</a>.  <a href="#a904dc2ee15dbdedd1b2dac4e0420fe15">More...</a><br /></td></tr>
<tr class="separator:a904dc2ee15dbdedd1b2dac4e0420fe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b75d9038a0e5b77482456af2311b0d"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:ad3b75d9038a0e5b77482456af2311b0d"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ad3b75d9038a0e5b77482456af2311b0d">make_map_initializer_with_help</a> (F func, std::vector&lt; std::string &gt; fields)</td></tr>
<tr class="memdesc:ad3b75d9038a0e5b77482456af2311b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on fields.  <a href="#ad3b75d9038a0e5b77482456af2311b0d">More...</a><br /></td></tr>
<tr class="separator:ad3b75d9038a0e5b77482456af2311b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc00952238c78dc6fbfc89bfe6deb8ee"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:acc00952238c78dc6fbfc89bfe6deb8ee"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#acc00952238c78dc6fbfc89bfe6deb8ee">make_map_initializer_with_help</a> (F func, std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; fields_with_help)</td></tr>
<tr class="memdesc:acc00952238c78dc6fbfc89bfe6deb8ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on passed in pairs, which the first entry in a pair is a yaml map key, and the second describes the field.  <a href="#acc00952238c78dc6fbfc89bfe6deb8ee">More...</a><br /></td></tr>
<tr class="separator:acc00952238c78dc6fbfc89bfe6deb8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63cb736dc5f8cbf6f6aad126825ab3d"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:aa63cb736dc5f8cbf6f6aad126825ab3d"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#aa63cb736dc5f8cbf6f6aad126825ab3d">make_map_initializer_with_help</a> (F func, std::vector&lt; std::string &gt; fields, std::vector&lt; std::string &gt; fields_help)</td></tr>
<tr class="memdesc:aa63cb736dc5f8cbf6f6aad126825ab3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on passed in vectors. The fields vector provides yaml map keys, and the fields_help vector provides help for the field at the same index.  <a href="#aa63cb736dc5f8cbf6f6aad126825ab3d">More...</a><br /></td></tr>
<tr class="separator:aa63cb736dc5f8cbf6f6aad126825ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81e360a765ce7e454fa3971f1f06cdd"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:ac81e360a765ce7e454fa3971f1f06cdd"><td class="memTemplItemLeft" align="right" valign="top">initializer_type_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ac81e360a765ce7e454fa3971f1f06cdd">make_sequence_initializer</a> (F func)</td></tr>
<tr class="memdesc:ac81e360a765ce7e454fa3971f1f06cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates factory initializer that expects a YAML sequence. The elements of the sequence will be passed as a YAML factory config to the factory of the argument type. The results will be passed in to function func.  <a href="#ac81e360a765ce7e454fa3971f1f06cdd">More...</a><br /></td></tr>
<tr class="separator:ac81e360a765ce7e454fa3971f1f06cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba056e293eb266e6ae286c6480ebe667"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename F &gt; </td></tr>
<tr class="memitem:aba056e293eb266e6ae286c6480ebe667"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#aba056e293eb266e6ae286c6480ebe667">make_sequence_initializer_with_help</a> (F func, std::vector&lt; std::string &gt; helps={})</td></tr>
<tr class="memdesc:aba056e293eb266e6ae286c6480ebe667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes yadi info with generated help for F.  <a href="#aba056e293eb266e6ae286c6480ebe667">More...</a><br /></td></tr>
<tr class="separator:aba056e293eb266e6ae286c6480ebe667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f9807cc4def04330e0f1e4dd480c9f"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:aa1f9807cc4def04330e0f1e4dd480c9f"><td class="memTemplItemLeft" align="right" valign="top">initializer_type_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#aa1f9807cc4def04330e0f1e4dd480c9f">make_yaml_as_initializer</a> ()</td></tr>
<tr class="memdesc:aa1f9807cc4def04330e0f1e4dd480c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an initializer which simply calls yaml.as&lt;BT&gt;() for some YAML node yaml.  <a href="#aa1f9807cc4def04330e0f1e4dd480c9f">More...</a><br /></td></tr>
<tr class="separator:aa1f9807cc4def04330e0f1e4dd480c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd6415252b551f9ffae445d25e30b7a"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a7bd6415252b551f9ffae445d25e30b7a"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; BT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a7bd6415252b551f9ffae445d25e30b7a">make_yaml_as_initializer_with_help</a> ()</td></tr>
<tr class="memdesc:a7bd6415252b551f9ffae445d25e30b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespaceyadi.html#a7bd6415252b551f9ffae445d25e30b7a" title="See make_yaml_as_initializer_with_help(). Adds help string with the yaml.as&lt;BT&gt;() call info...">make_yaml_as_initializer_with_help()</a>. Adds help string with the yaml.as&lt;BT&gt;() call info.  <a href="#a7bd6415252b551f9ffae445d25e30b7a">More...</a><br /></td></tr>
<tr class="separator:a7bd6415252b551f9ffae445d25e30b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e57191502ac483355c06b47fa228a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb3e57191502ac483355c06b47fa228a"><td class="memTemplItemLeft" align="right" valign="top">initializer_type_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#afb3e57191502ac483355c06b47fa228a">make_yaml_as_initializer</a> ()</td></tr>
<tr class="memdesc:afb3e57191502ac483355c06b47fa228a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an initializer which simply calls yaml.as&lt;BT&gt;() for some YAML node yaml.  <a href="#afb3e57191502ac483355c06b47fa228a">More...</a><br /></td></tr>
<tr class="separator:afb3e57191502ac483355c06b47fa228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1095a9041ff52bd8df8ccd475fc18fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1095a9041ff52bd8df8ccd475fc18fc"><td class="memTemplItemLeft" align="right" valign="top">yadi_info_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ac1095a9041ff52bd8df8ccd475fc18fc">make_yaml_as_initializer_with_help</a> ()</td></tr>
<tr class="memdesc:ac1095a9041ff52bd8df8ccd475fc18fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="namespaceyadi.html#a7bd6415252b551f9ffae445d25e30b7a" title="See make_yaml_as_initializer_with_help(). Adds help string with the yaml.as&lt;BT&gt;() call info...">make_yaml_as_initializer_with_help()</a>. Adds help string with the yaml.as&lt;BT&gt;() call info.  <a href="#ac1095a9041ff52bd8df8ccd475fc18fc">More...</a><br /></td></tr>
<tr class="separator:ac1095a9041ff52bd8df8ccd475fc18fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495ab0c09cfb0aba37fd2115350d81d9"><td class="memItemLeft" align="right" valign="top">YAML::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a495ab0c09cfb0aba37fd2115350d81d9">merge_yaml</a> (YAML::Node const &amp;left, YAML::Node const &amp;)</td></tr>
<tr class="separator:a495ab0c09cfb0aba37fd2115350d81d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848729993f692098bf175774503b80ee"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a848729993f692098bf175774503b80ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a848729993f692098bf175774503b80ee">register_type</a> (std::string type, yadi_info_t&lt; BT &gt; yadis)</td></tr>
<tr class="memdesc:a848729993f692098bf175774503b80ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equibalent to factory&lt;BT&gt;::register_type(type, yadis)  <a href="#a848729993f692098bf175774503b80ee">More...</a><br /></td></tr>
<tr class="separator:a848729993f692098bf175774503b80ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78deb2170c9d148eee9194f632b03c"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:acb78deb2170c9d148eee9194f632b03c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#acb78deb2170c9d148eee9194f632b03c">register_type</a> (std::string type, initializer_type_t&lt; BT &gt; initializer)</td></tr>
<tr class="separator:acb78deb2170c9d148eee9194f632b03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5041a043acc0144113854035fb8beb2a"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename IT &gt; </td></tr>
<tr class="memitem:a5041a043acc0144113854035fb8beb2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a5041a043acc0144113854035fb8beb2a">register_type</a> (std::string type)</td></tr>
<tr class="memdesc:a5041a043acc0144113854035fb8beb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers type using yaml_init function as initializer.  <a href="#a5041a043acc0144113854035fb8beb2a">More...</a><br /></td></tr>
<tr class="separator:a5041a043acc0144113854035fb8beb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b26848cc9dc3459c264cc734308204"><td class="memTemplParams" colspan="2">template&lt;typename BT , typename IT &gt; </td></tr>
<tr class="memitem:ad2b26848cc9dc3459c264cc734308204"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#ad2b26848cc9dc3459c264cc734308204">register_type_no_arg</a> (std::string type)</td></tr>
<tr class="memdesc:ad2b26848cc9dc3459c264cc734308204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers type to initializer that will construct IT using default constructor.  <a href="#ad2b26848cc9dc3459c264cc734308204">More...</a><br /></td></tr>
<tr class="separator:ad2b26848cc9dc3459c264cc734308204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e048a8bef5792a7c5b3aae435999d"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a5f8e048a8bef5792a7c5b3aae435999d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a5f8e048a8bef5792a7c5b3aae435999d">register_alias</a> (std::string alias, std::string type, YAML::Node config)</td></tr>
<tr class="memdesc:a5f8e048a8bef5792a7c5b3aae435999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers alias to type and config pair. When create is called for alias the passed in and registered configs are merged and the initializer registered to type is called with the result.  <a href="#a5f8e048a8bef5792a7c5b3aae435999d">More...</a><br /></td></tr>
<tr class="separator:a5f8e048a8bef5792a7c5b3aae435999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0879baf3dca6ee9a7d4387bfca43f8dd"><td class="memTemplParams" colspan="2">template&lt;typename BT &gt; </td></tr>
<tr class="memitem:a0879baf3dca6ee9a7d4387bfca43f8dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceyadi.html#a0879baf3dca6ee9a7d4387bfca43f8dd">register_aliases</a> (YAML::Node aliases)</td></tr>
<tr class="memdesc:a0879baf3dca6ee9a7d4387bfca43f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads aliases from a YAML file. The file should be a map of the format... alias: type: actualType config: ...  <a href="#a0879baf3dca6ee9a7d4387bfca43f8dd">More...</a><br /></td></tr>
<tr class="separator:a0879baf3dca6ee9a7d4387bfca43f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>YADI. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac39d8f532bdf81e833cb117160a6440a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39d8f532bdf81e833cb117160a6440a">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structyadi_1_1adapter.html">adapter</a>&lt; FT &gt;::output_type yadi::create </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as adapter&lt;FT&gt;::create(type, config);. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>Type used to derive factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">config</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00122">122</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a82056df230021b8fc8be27978644629d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82056df230021b8fc8be27978644629d">&#9670;&nbsp;</a></span>ctr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename IT , typename... ARGS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt; yadi::ctr </td>
          <td>(</td>
          <td class="paramtype">ARGS...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct IT via contructor with the given arguments. This is intended to be used with a yaml binding initializer such as make_sequence_initializer(&amp;<a class="el" href="namespaceyadi.html#a82056df230021b8fc8be27978644629d" title="Construct IT via contructor with the given arguments. This is intended to be used with a yaml binding...">ctr&lt;BT, IT, MyCtrArgs...&gt;</a>, ...). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>Base type. </td></tr>
    <tr><td class="paramname">IT</td><td>Implementation type. </td></tr>
    <tr><td class="paramname">ARGS</td><td>Argument types of constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments for constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr_type_t&lt;BT&gt; via constructor of IT. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00374">374</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a85138aa0433192beaf4d0e67dd50cb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85138aa0433192beaf4d0e67dd50cb23">&#9670;&nbsp;</a></span>from_yaml()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OT yadi::from_yaml </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>factory_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulls type and config from YAML. This function is especially usefil when loading nested types from YAML configuration. If factory_config is a scalar string it will be used as type. If factory_config is a map then "type" and "config" keys will be pulled from it and used as such, unless the base type indicates it should be created directly from yaml. In this case factory_config is used as the config passed to the adapter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OT</td><td>The desired output type. The factory base type will be derived from this using derive_base_type_t&lt;OT&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory_config</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00127">127</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a829744f635593fef1c05b0f9b01a8aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829744f635593fef1c05b0f9b01a8aa2">&#9670;&nbsp;</a></span>from_yaml_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt;BT&gt; yadi::from_yaml_base </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>config</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to from_yaml&lt;ptr_type_t&lt;base_type&gt;&gt;(config) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>The factory baes type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00085">85</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a5c72b55cccde908a9828431855e3b5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c72b55cccde908a9828431855e3b5e5">&#9670;&nbsp;</a></span>from_yamls()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OT , typename OI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::from_yamls </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>factory_configs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OI&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate output iterator from sequence of factory configs (anything from_yaml accepts). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
    <tr><td class="paramname">OI</td><td>Output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory_configs</td><td></td></tr>
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00165">165</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a425268f5a35df74d449b5e1f44f39c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425268f5a35df74d449b5e1f44f39c22">&#9670;&nbsp;</a></span>from_yamls_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename OI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::from_yamls_base </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>factory_configs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OI&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to from_yamls&lt;ptr_type_t&lt;base_type&gt;&gt;(factory_configs, out);. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
    <tr><td class="paramname">OI</td><td>output iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory_configs</td><td></td></tr>
    <tr><td class="paramname">out</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00107">107</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a29e6a880477f8ed0163fbfc66aa6e5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e6a880477f8ed0163fbfc66aa6e5ba">&#9670;&nbsp;</a></span>init_no_arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt; yadi::init_no_arg </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call no argument constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>Base type. </td></tr>
    <tr><td class="paramname">IT</td><td>Implementation type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer type of base type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00369">369</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="afde7bc09c5c23344ded1f10f21386272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde7bc09c5c23344ded1f10f21386272">&#9670;&nbsp;</a></span>init_yaml()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceyadi.html#a92290eb27cd90666aa87b17d854af9fe">ptr_type_t</a>&lt; BT &gt; yadi::init_yaml </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs IT via a constructor that accepts YAML and returns as pointer to BT, ptr_type_t&lt;BT&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>Use to determine pointer type. </td></tr>
    <tr><td class="paramname">IT</td><td>Implementation type. Type to construct </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Argument to constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed type as ptr_type_t&lt;BT&gt; </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00364">364</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a97efcea8efe1e35d98961c88e21d5b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97efcea8efe1e35d98961c88e21d5b31">&#9670;&nbsp;</a></span>make_caching_initializer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initializer_type_t&lt; BT &gt; yadi::make_caching_initializer </td>
          <td>(</td>
          <td class="paramtype">initializer_type_t&lt; BT &gt; const &amp;&#160;</td>
          <td class="paramname"><em>initializing_initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps initializer in caching functor. The wrapped initializer must produce a shared pointer. A weak pointer to the created shared pointer is stored upon first creation. In subsequence calls the weak pointer is checking and used if it's still valid, otherwise a new shared pointer is created and the weak pointer is updated. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initializing_initializer</td><td>The initializer to wrap, which is used to create the shared pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An existing instance if it exists, otherwise a new instance is created. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00459">459</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a71eac695c975b9f2b7f9d9611725b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eac695c975b9f2b7f9d9611725b94e">&#9670;&nbsp;</a></span>make_caching_initializer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt; BT &gt; yadi::make_caching_initializer </td>
          <td>(</td>
          <td class="paramtype">yadi_info_t&lt; BT &gt;&#160;</td>
          <td class="paramname"><em>yi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function which updated just the initializer of a yadi info. See make_caching_initializer(initializer_type_t&lt;BT&gt;) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yi</td><td>The yadi info to update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The passed in yadi info with updated initializer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00485">485</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a904dc2ee15dbdedd1b2dac4e0420fe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904dc2ee15dbdedd1b2dac4e0420fe15">&#9670;&nbsp;</a></span>make_map_initializer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initializer_type_t&lt; BT &gt; yadi::make_map_initializer </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence in the order the fields are provided. Once the sequence is created it's treated the behavior is the same as <a class="el" href="namespaceyadi.html#ac81e360a765ce7e454fa3971f1f06cdd" title="Creates factory initializer that expects a YAML sequence. The elements of the sequence will be passed...">make_sequence_initializer(F)</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">fields</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00401">401</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="ad3b75d9038a0e5b77482456af2311b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b75d9038a0e5b77482456af2311b0d">&#9670;&nbsp;</a></span>make_map_initializer_with_help() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt; BT &gt; yadi::make_map_initializer_with_help </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on fields. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">fields</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00415">415</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="acc00952238c78dc6fbfc89bfe6deb8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc00952238c78dc6fbfc89bfe6deb8ee">&#9670;&nbsp;</a></span>make_map_initializer_with_help() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt; BT &gt; yadi::make_map_initializer_with_help </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt;&#160;</td>
          <td class="paramname"><em>fields_with_help</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on passed in pairs, which the first entry in a pair is a yaml map key, and the second describes the field. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">fields_with_help</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00420">420</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="aa63cb736dc5f8cbf6f6aad126825ab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63cb736dc5f8cbf6f6aad126825ab3d">&#9670;&nbsp;</a></span>make_map_initializer_with_help() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt; BT &gt; yadi::make_map_initializer_with_help </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>fields_help</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespaceyadi.html#a904dc2ee15dbdedd1b2dac4e0420fe15" title="Expects a YAML map. The fields are pulled from the map and their values are used to create a sequence...">make_map_initializer(F, std::vector&lt;std::string&gt;)</a>. Adds generated help information based on passed in vectors. The fields vector provides yaml map keys, and the fields_help vector provides help for the field at the same index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
    <tr><td class="paramname">fields</td><td></td></tr>
    <tr><td class="paramname">fields_help</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00433">433</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="ac81e360a765ce7e454fa3971f1f06cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81e360a765ce7e454fa3971f1f06cdd">&#9670;&nbsp;</a></span>make_sequence_initializer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initializer_type_t&lt; BT &gt; yadi::make_sequence_initializer </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates factory initializer that expects a YAML sequence. The elements of the sequence will be passed as a YAML factory config to the factory of the argument type. The results will be passed in to function func. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
    <tr><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00379">379</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="aba056e293eb266e6ae286c6480ebe667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba056e293eb266e6ae286c6480ebe667">&#9670;&nbsp;</a></span>make_sequence_initializer_with_help()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt; BT &gt; yadi::make_sequence_initializer_with_help </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>helps</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes yadi info with generated help for F. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
    <tr><td class="paramname">F</td><td>Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to find yaml to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated yadi info </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00385">385</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="aa1f9807cc4def04330e0f1e4dd480c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f9807cc4def04330e0f1e4dd480c9f">&#9670;&nbsp;</a></span>make_yaml_as_initializer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initializer_type_t&lt;BT&gt; yadi::make_yaml_as_initializer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an initializer which simply calls yaml.as&lt;BT&gt;() for some YAML node yaml. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the yaml.as&lt;BT&gt;() call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00353">353</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="afb3e57191502ac483355c06b47fa228a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3e57191502ac483355c06b47fa228a">&#9670;&nbsp;</a></span>make_yaml_as_initializer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">initializer_type_t&lt;T&gt; yadi::make_yaml_as_initializer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an initializer which simply calls yaml.as&lt;BT&gt;() for some YAML node yaml. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>base type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the yaml.as&lt;BT&gt;() call. </dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00353">353</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a7bd6415252b551f9ffae445d25e30b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd6415252b551f9ffae445d25e30b7a">&#9670;&nbsp;</a></span>make_yaml_as_initializer_with_help() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt;BT&gt; yadi::make_yaml_as_initializer_with_help </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespaceyadi.html#a7bd6415252b551f9ffae445d25e30b7a" title="See make_yaml_as_initializer_with_help(). Adds help string with the yaml.as&lt;BT&gt;() call info...">make_yaml_as_initializer_with_help()</a>. Adds help string with the yaml.as&lt;BT&gt;() call info. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00358">358</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="ac1095a9041ff52bd8df8ccd475fc18fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1095a9041ff52bd8df8ccd475fc18fc">&#9670;&nbsp;</a></span>make_yaml_as_initializer_with_help() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">yadi_info_t&lt;T&gt; yadi::make_yaml_as_initializer_with_help </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="namespaceyadi.html#a7bd6415252b551f9ffae445d25e30b7a" title="See make_yaml_as_initializer_with_help(). Adds help string with the yaml.as&lt;BT&gt;() call info...">make_yaml_as_initializer_with_help()</a>. Adds help string with the yaml.as&lt;BT&gt;() call info. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00358">358</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
<a id="a495ab0c09cfb0aba37fd2115350d81d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495ab0c09cfb0aba37fd2115350d81d9">&#9670;&nbsp;</a></span>merge_yaml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">YAML::Node yadi::merge_yaml </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If both types are maps then they are merged with left taking priority. If right is not defined or is null then left. If left is not defined or is null then right. Otherwise, error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="registration_8cpp_source.html#l00007">7</a> of file <a class="el" href="registration_8cpp_source.html">registration.cpp</a>.</p>

</div>
</div>
<a id="ace9d761848d60ab00f257fdd9f5f2f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d761848d60ab00f257fdd9f5f2f21">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::parse </td>
          <td>(</td>
          <td class="paramtype">OT &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>factory_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate out from factory config. The factory type is derived from ptr_type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OT</td><td>output type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td></td></tr>
    <tr><td class="paramname">factory_config</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8hpp_source.html#l00184">184</a> of file <a class="el" href="create__utils_8hpp_source.html">create_utils.hpp</a>.</p>

</div>
</div>
<a id="a5f8e048a8bef5792a7c5b3aae435999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e048a8bef5792a7c5b3aae435999d">&#9670;&nbsp;</a></span>register_alias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_alias </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YAML::Node&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers alias to type and config pair. When create is called for alias the passed in and registered configs are merged and the initializer registered to type is called with the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td></td></tr>
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">config</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00114">114</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="a0879baf3dca6ee9a7d4387bfca43f8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0879baf3dca6ee9a7d4387bfca43f8dd">&#9670;&nbsp;</a></span>register_aliases()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_aliases </td>
          <td>(</td>
          <td class="paramtype">YAML::Node&#160;</td>
          <td class="paramname"><em>aliases</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads aliases from a YAML file. The file should be a map of the format... alias: type: actualType config: ... </p>
<p>For each entry <a class="el" href="namespaceyadi.html#a5f8e048a8bef5792a7c5b3aae435999d" title="Registers alias to type and config pair. When create is called for alias the passed in and registered...">register_alias()</a> is called. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aliases</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00122">122</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="a848729993f692098bf175774503b80ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848729993f692098bf175774503b80ee">&#9670;&nbsp;</a></span>register_type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_type </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">yadi_info_t&lt; BT &gt;&#160;</td>
          <td class="paramname"><em>yadis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equibalent to factory&lt;BT&gt;::register_type(type, yadis) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">initializer</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00094">94</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="acb78deb2170c9d148eee9194f632b03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb78deb2170c9d148eee9194f632b03c">&#9670;&nbsp;</a></span>register_type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_type </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">initializer_type_t&lt; BT &gt;&#160;</td>
          <td class="paramname"><em>initializer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
    <tr><td class="paramname">initializer</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00099">99</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="a5041a043acc0144113854035fb8beb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5041a043acc0144113854035fb8beb2a">&#9670;&nbsp;</a></span>register_type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_type </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers type using yaml_init function as initializer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td>The factory type to use </td></tr>
    <tr><td class="paramname">IT</td><td>The type to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The name to register the type under </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00104">104</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="ad2b26848cc9dc3459c264cc734308204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b26848cc9dc3459c264cc734308204">&#9670;&nbsp;</a></span>register_type_no_arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void yadi::register_type_no_arg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers type to initializer that will construct IT using default constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BT</td><td></td></tr>
    <tr><td class="paramname">IT</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="registration_8hpp_source.html#l00109">109</a> of file <a class="el" href="registration_8hpp_source.html">registration.hpp</a>.</p>

</div>
</div>
<a id="a0058efe8131ffa9184aa772e88c8f160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0058efe8131ffa9184aa772e88c8f160">&#9670;&nbsp;</a></span>type_by_value_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string const  &amp; yadi::type_by_value_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the key used for initializers creating by value directly from yaml. </p>
<dl class="section return"><dt>Returns</dt><dd>The key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="create__utils_8cpp_source.html#l00007">7</a> of file <a class="el" href="create__utils_8cpp_source.html">create_utils.cpp</a>.</p>

</div>
</div>
<a id="a8552ed4e9350993901558fb0db1e0906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8552ed4e9350993901558fb0db1e0906">&#9670;&nbsp;</a></span>yaml_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T yadi::yaml_as </td>
          <td>(</td>
          <td class="paramtype">YAML::Node const &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns config.as&lt;T&gt;(). Signature matches factory initializer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="initializers_8hpp_source.html#l00347">347</a> of file <a class="el" href="initializers_8hpp_source.html">initializers.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
